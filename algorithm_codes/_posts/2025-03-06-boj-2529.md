---
title: "BOJ 2529 부등호 (Java)"
excerpt: 백준 2529 문제의 풀이입니다.
tags: 
  - [Blog, algorithm, BOJ]
toc: true
toc_sticky: true
date: 2025-03-06
last_modified_at: 2025-03-06
---

[2529 부등호](https://www.acmicpc.net/problem/2529)

# 문제 탐색하기

- 두 종류의 부등호 기호 기준에 의거해 선택되는 숫자의 최솟값과 최댓값을 구해야 한다.

# 코드 설계하기

- 만약에 DFS로 순회를 한다면, 최초 선택되는 값은 최솟값 - 최후 순회되는 값은 최댓값이다.
	- 따라서 최솟값이 선택된 이후 최솟값 출력 > 이후 최댓값 출력하는 방식으로 하거나 / 최솟값 저장 후 최댓값은 계속 갱신하는 방식으로 구현하면 된다.

## 구현 방법

1. N과 해당하는 부등호 값을 입력받는다.
2. 정답으로 출력할 최솟값과 최댓값 변수, 방문 여부를 저장할 `visited`배열 객체를 저장한다.

## 시간 복잡도

- 부등호 최대 개수 9 > 숫자 길이 10
- 최대 시간 복잡도 n! -> n = 10 이므로 최대 연산 개수 3,628,800
	- Brute Force 방식을 사용하여도 1초 이내에 연산이 가능하다.


# 시도 회차 별 수정사항(Optional)


# 정답 코드 (Java)

```java

```

# 정답 코드 (Python)

```python
import sys

r = sys.stdin.readline

N = int(r())
numList = list(map(str, r().split()))
max_val, min_val = None, None

visited = [False] * 10 # 0-9

def DFS(x, num): # 재귀함수
    global max_val, min_val
    
    if x == N+1:
        if not min_val:
            min_val = num
        else:
            max_val = num
        return
    for i in range(10):
        if not visited[i]: # 방문하지 않았으면
            if x == 0 or possible(num[-1], str(i), numList[x-1]):
                visited[i] = True
                DFS(x+1,num + str(i))
                visited[i] = False

def possible(i,j,k): # 가능한지 여부를 판정
    if k == '<':
        return i<j
    if k == '>':
        return i>j

    return True

DFS(0,"")
print(max_val)
print(min_val)

```