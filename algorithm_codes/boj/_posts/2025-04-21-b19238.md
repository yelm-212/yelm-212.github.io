---
title:  "BOJ 19238 스타트 택시(Java)"
excerpt: "백준 19238번 문제의 풀이입니다."

tags:
  - [Blog, algorithm, BOJ, BFS]

toc: true
toc_sticky: true
 
date: 2025-04-21
last_modified_at: 2025-04-21

---

# 문제 탐색하기
<!-- %% 정답은 무엇인가? %%
%% 코드 구현은 어떻게 할 것인가? %% -->

- 손님을 도착지로 데려다줄 때마다 연료가 충전되고, 연료가 바닥나면 그 날의 업무가 끝난다.
- 활동할 영역은 N×N 크기의 격자로 나타낼 수 있고, 각 칸은 비어 있거나 벽이 놓여 있다. 
- 택시가 빈칸에 있을 때, 상하좌우로 인접한 빈칸 중 하나로 이동할 수 있으며 항상 최단 경로로 이동한다.
- M명의 승객을 태우는 것이 목표
- M명의 승객은 빈칸 중 하나에 서 있으며, 다른 빈칸 중 하나로 이동하려고 한다. 여러 승객이 같이 탑승하는 경우는 없다. 
  - 따라서 한 승객을 태워 목적지로 이동시키는 일을 M번 반복해야 한다. 

- 태울 승객을 고를 때는 현재 위치에서 최단거리가 가장 짧은 승객을 고른다. 
  - 그런 승객이 여러 명이면 그중 행 번호가 가장 작은 승객을, 그런 승객도 여러 명이면 그중 열 번호가 가장 작은 승객을 고른다. 
  - 택시와 승객이 같은 위치에 서 있으면 그 승객까지의 최단거리는 0이다.
  - 연료는 한 칸 이동할 때마다 1씩 소모된다. 
  - 승객을 목적지로 이동시키면 그 승객을 태워 이동하면서 소모한 연료의 양의 두 배가 충전된다. 
  - 이동하는 도중에 연료가 바닥나면 이동에 실패하고 그 날의 업무가 끝난다. 
  - 승객을 목적지로 이동시킨 후 연료가 바닥나는 경우는 실패한 것으로 간주하지 않는다. 

모든 승객을 성공적으로 데려다줄 수 있는지 알아보고, 데려다줄 수 있을 경우 최종적으로 남는 연료의 양을 출력하는 프로그램을 작성하라.

**입력**

- 첫 줄에 N, M, 연료의 양이 주어진다.
- 다음 N개의 줄에 걸쳐 N×N 크기의 격자의 정보가 주어진다. 
  - 0은 빈칸, 1은 벽을 나타낸다. 
  - 벽이 있는 칸에는 승객이 서 있을 수 없다. 
  - 또, 벽이 있는 칸은 택시가 이동할 수 없다. 
- 백준이 운전을 시작하는 칸의 행 번호와 열 번호가 주어진다. 
  - 행과 열 번호는 1 이상 N 이하의 자연수이고, 운전을 시작하는 칸은 빈칸이다.
- 다음 M개의 줄에 걸쳐 각 승객의 출발지의 행과 열 번호, 그리고 목적지의 행과 열 번호가 주어진다.


**출력**

- 모든 손님을 이동시키고 연료를 충전했을 때 남은 연료의 양을 출력한다. 
- 이동 도중에 연료가 바닥나서 다음 출발지나 목적지로 이동할 수 없으면 -1을 출력한다. 
- 모든 손님을 이동시킬 수 없는 경우에도 -1을 출력한다.

**예제**

```bash
# 입력 
6 3 15
0 0 1 0 0 0
0 0 1 0 0 0
0 0 0 0 0 0
0 0 0 0 0 0 
0 0 0 0 0 0
0 0 0 0 0 0
6 5
2 2 5 6
5 4 1 6
4 2 3 5

# 출력
14
```

# 코드 설계하기
<!-- %% 어떤 순서로 코드 작성하고, 어떤 함수 작성할 것인지? %%
%% 설계를 잘 하면 오히려 문제 풀이 시간 단축된다. 설계를 잘 하자. %% -->

## 구현 방법

```bash
while (모든 승객을 태울 때까지) {
    1. BFS로 가장 가까운 승객 찾기 (findNearestPassenger)
    2. BFS로 목적지까지 거리 계산 (findDistanceToDestination)
    3. 연료 관리
    4. 택시 위치 업데이트
}
```

## 시간 복잡도


# 시도 회차 별 수정사항(Optional)
<!-- %% 틀렸습니다 나올때... 왜 틀렸는가? 에 대한 고민. %% -->

# 정답 코드 (Java)

{% raw %}
```java
import java.io.*;
import java.util.*;

public class Main {
    static int N, M;
    static int fuel;
    static int[][] map;
    static int taxiRow, taxiCol;
    static int[][] passengers; // [승객번호][0: 출발행, 1: 출발열, 2: 도착행, 3: 도착열]
    static boolean[] completed;
    static int[] dr = {-1, 1, 0, 0};
    static int[] dc = {0, 0, -1, 1};

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        
        N = Integer.parseInt(st.nextToken());
        M = Integer.parseInt(st.nextToken());
        fuel = Integer.parseInt(st.nextToken());
        
        map = new int[N+1][N+1];
        for (int i = 1; i <= N; i++) {
            st = new StringTokenizer(br.readLine());
            for (int j = 1; j <= N; j++) {
                map[i][j] = Integer.parseInt(st.nextToken());
            }
        }
        
        st = new StringTokenizer(br.readLine());
        taxiRow = Integer.parseInt(st.nextToken());
        taxiCol = Integer.parseInt(st.nextToken());
        
        passengers = new int[M+1][4];
        for (int i = 1; i <= M; i++) {
            st = new StringTokenizer(br.readLine());
            passengers[i][0] = Integer.parseInt(st.nextToken()); // 출발 행
            passengers[i][1] = Integer.parseInt(st.nextToken()); // 출발 열
            passengers[i][2] = Integer.parseInt(st.nextToken()); // 도착 행
            passengers[i][3] = Integer.parseInt(st.nextToken()); // 도착 열
        }
        
        completed = new boolean[M+1];
        
        // 모든 승객을 태워 목적지로 이동시키기
        for (int i = 0; i < M; i++) {
            int passengerIndex = findNearestPassenger();
            if (passengerIndex == -1 || fuel <= 0) {
                System.out.println(-1);
                return;
            }
            
            // 승객을 태운 후 목적지로 이동
            int[] passenger = passengers[passengerIndex];
            int distance = bfs(taxiRow, taxiCol, passenger[2], passenger[3]);
            if (distance == -1 || fuel < distance) {
                System.out.println(-1);
                return;
            }
            
            // 연료 소비 및 충전
            fuel -= distance;
            fuel += (distance * 2);
            
            // 택시 위치 업데이트
            taxiRow = passenger[2];
            taxiCol = passenger[3];
            
            // 승객 완료 처리
            completed[passengerIndex] = true;
        }
        
        System.out.println(fuel);
    }
    
    // 가장 가까운 승객 찾기
    static int findNearestPassenger() {
        int minDistance = Integer.MAX_VALUE;
        int minIndex = -1;
        int minRow = Integer.MAX_VALUE;
        int minCol = Integer.MAX_VALUE;
        
        // 아직 태우지 않은 승객들에 대해 거리 계산
        for (int i = 1; i <= M; i++) {
            if (completed[i]) continue;
            
            int distance = bfs(taxiRow, taxiCol, passengers[i][0], passengers[i][1]);
            if (distance == -1) continue; // 갈 수 없는 경우
            
            if (distance > fuel) continue; // 연료 부족
            
            if (distance < minDistance || 
                (distance == minDistance && (passengers[i][0] < minRow || 
                (passengers[i][0] == minRow && passengers[i][1] < minCol)))) {
                minDistance = distance;
                minIndex = i;
                minRow = passengers[i][0];
                minCol = passengers[i][1];
            }
        }
        
        if (minIndex != -1) {
            // 선택된 승객에게 가는데 연료 소비
            fuel -= minDistance;
            // 택시 위치 업데이트
            taxiRow = passengers[minIndex][0];
            taxiCol = passengers[minIndex][1];
        }
        
        return minIndex;
    }
    
    // BFS로 최단 거리 계산
    static int bfs(int startRow, int startCol, int endRow, int endCol) {
        if (startRow == endRow && startCol == endCol) return 0;
        
        Queue<int[]> queue = new LinkedList<>();
        boolean[][] visited = new boolean[N+1][N+1];
        
        queue.offer(new int[]{startRow, startCol, 0});
        visited[startRow][startCol] = true;
        
        while (!queue.isEmpty()) {
            int[] curr = queue.poll();
            int r = curr[0];
            int c = curr[1];
            int dist = curr[2];
            
            for (int i = 0; i < 4; i++) {
                int nr = r + dr[i];
                int nc = c + dc[i];
                
                if (nr < 1 || nr > N || nc < 1 || nc > N) continue;
                if (map[nr][nc] == 1 || visited[nr][nc]) continue;
                
                if (nr == endRow && nc == endCol) {
                    return dist + 1;
                }
                
                visited[nr][nc] = true;
                queue.offer(new int[]{nr, nc, dist + 1});
            }
        }
        
        return -1; // 도달할 수 없는 경우
    }
}
```
{% endraw %}

